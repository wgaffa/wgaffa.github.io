---
date: 2025-10-18
title: Learn Haskell with Advent of Code, 2015 day 1
---

# Problem

The full problem statement is at [Advent of Code 2015 day 1](https://adventofcode.com/2015/day/1).

We are tasked to find what floor Santa ultimately ends up on after using an elevator
and following an instruction consisting of '**(**' for going up and '**)**' for going down.

## Breaking it down

Let's break this down a bit. Try to think of what data you need and what you need to use
that data to get your end result.

::: {.spoiler label="breakdown"}

- Read contents of a file
- Represent an Up and Down value
- Each character should map to an *Up* or *Down* value
- Transforming a list of characters into a list *Up* and *Down* values
- Map a *Direction* value into an elevation change representation
- Transform the list of *Up* and *Down* values to a list of integers
- Add each number up in the list of integers

:::

::: {.spoiler label="first step"}

### Read contents of a file

To read from a file there is a simple function named *readFile* with the type `FilePath -> IO String`.
The result of the file will be inside an IO monad and for now the only thing you need is a way to
retrieve that *String* from inside the IO. We can bind the value inside the IO monad with the *<-* arrow,
**but** only if we are inside an IO monad ourselves. We will use this in our main like this.

```
main :: IO ()
main = do
    contents <- readFile "input.txt"
    ...
```

The `readFile "input.txt"` is an *IO* action and specifically it has the type `IO String` that
when executed by the runtime produces a `String`. `contents` is then bound to
this `String` where we can use it for further processing.

But for now just **Trust me bro**, it hopefully will become clearer the more you get used to it.

:::

::: {.spoiler label="second step"}

### Represent an Up and Down value

Here we have to think how to represent an *Up* or *Down* value instead of its character
representation. We do this more for clarity and code quality and is strictly not needed
for Advent of Code problems most of the time.

```haskell
data Direction = Up | Down
  deriving (Show)
```

The `data` keyword introduces a new type *Direction* for us to use that can hold one of
two values, it's either an `Up` or `Down` value.

:::

::: {.spoiler label="third step"}

### Each character should map to an *Up* or *Down* value

We need a way to map a character to a `Direction` value and we do that with a function
that takes a `Char` as input and returns `Direction`.

```haskell
charToDirection :: Char -> Direction
charToDirection '(' = Up
charToDirection ')' = Down
charToDirection ch = error $ "Critical error, unrecognized input " ++ [ch]
```

Here we start by declaring the function `charToDirection` as the type `Char -> Direction`
and in simple terms this means this is a function that takes a `Char` type and maps that to
a type of `Direction`.

We then proceed to do some *pattern matching* on the `Char` type and check if it's an '*(*' or '*)*'
and maps those values to `Up` and `Down` respectively.

The last clause uses the variable *ch* to match all remaining characters.
Since AoC input aren't very specific on how to handle unknown input, we exit with a panic message
on the last line. We could use better error handling but what should we return instead?
The AoC does not state what should happen if something goes wrong so I opt to just
throw an error message and quit the program.

The `++` is a function that concatenates two lists together. So therefore we need to take
the character and surround it with brackets to make it a one element list, making it a list
and able to concatenate it with the first list.

**Note** that the pattern matches are matched one after another.
If the last line would be moved to the top, then it would always match and would always throw
an error. Do keep in mind the ordering of pattern matches.

Here's an example that would always crash for example

```haskell
charToDirectionCrash :: Char -> Direction
charToDirectionCrash ch = error $ "Critical error, unrecognized input " ++ [ch]
charToDirectionCrash '(' = Up
charToDirectionCrash ')' = Down
```

:::

::: {.spoiler label="step four"}

### Transforming a list of characters into a list *Up* and *Down* values

Now we want to take a list of characters and turn that into a list of `Direction` values
that are either *Up* or *Down*. So we have a `[Char]` also known as `String` and want to
transform that into a `[Direction]`.

```haskell
instructionParser :: String -> [Direction]
instructionParser [] = []
instructionParser (x : xs) = charToDirection x : instructionParser xs
```

:::::: {.spoiler .pl3 label="Intermediate technique"}
You can use the below function as well and to understand it I suggest learning more about
*Functors*. **Note** that the argument is now gone from the implementation of `functorVariant`,
this is something called either *tacit* or *point free* programming and is something that
I suggest you should get used to. Note that it also reduces some readability so use it but
it also takes away something that we programmers have a hard time to do, namely to name variables.

```haskell
functorVariant :: String -> [Direction]
functorVariant = fmap charToDirection
```
::::::

:::

::: {.spoiler label="step five"}

### Map a *Direction* value into an elevation change representation

We are still not able to use a *Direction* type as a value to add together and therefore we
create a new function that maps a *Direction* to an integer value that represent the elevation change
of each direction.

```haskell
elevationChange :: Direction -> Int
elevationChange Up = 1
elevationChange Down = -1
```

:::

::: {.spoiler label="step six"}

### Transform the list of *Up* and *Down* values to a list of integers

If we have a list of *Direction* and wants a list of integers based on each of the values in
the list we need a function that takes each element of the list and applies a function to that value
and returns a new list for each of those function applications.

Luckily there exists one of those already for the *List* type called map, or fmap.
Our new function then becomes:

```haskell
elevations :: [Direction] -> [Int]
elevations = fmap elevationChange
```

:::

::: {.spoiler label="step seven"}

### Add each number up in the list of integers

To get the sum of all integers we can take the help of the function *sum* that has the type
`[Int] -> Int` in our case. *sum* actually has a different type with polymorphic types
but let's not get into that. This means we can call sum after we have our list of elevation changes.
The expression on the right uses something called function composition and is essentially a way to
chain several functions together into one single one.

```haskell
solvePart1 :: [Direction] -> Int
solvePart1 = sum . elevations
```

Remember that we had these types before `instructionParser :: String -> [Direction]`, `elevations :: [Direction] -> [Int]` and `sum :: [Int] -> Int`.
Together they become a function with the type `String -> Int`. 

In haskell we like to boast about referential transparency and we can show that here easily. What referential
transparency means is we can just replace values with their implementation. Take the *elevations* part for example
in the function expression, we can replace that with the content of that function where it then reads
`solvePart1 = sum . fmap elevationChange`. And it will behave the same.

So let's put our puzzle pieces together into our main that is the entry point of our application.

```haskell
main :: IO ()
main = do
    content <- readFile "input.txt"
    let part1 = solvePart1 . instructionParser $ content
        part2 = solvePart2 . instructionParser $ content

    print part1
    print part2
```

When we chain many commands inside a monad we use the *do* syntax to do that.

Next we use the special syntax *<-* to bind the result of an IO monad to the pattern on the left.
And remember that we are currently in an IO monad so this is acceptable and here we use a catch all
pattern with the named *content* so that we can reference it later.

After that we create a local binding with the *let* keyword. 

:::::: {.spoiler label="Further improvements using functors"}

As many programmers hate is repeating ourselves. Although for this short Advent of Code problem we might
not bother but for the sake of learning.

See that `. instructionParser $ content`? We are describing the same behaviour on *content* but never
use *content* without its raw string input as it was read from the file. Let's combine this using
another function used when working on Functors, namely the `<$>`. The `<$>` function is exactly like `fmap`
but with the arguments flipped.

So remember that `readFile "input.txt"` is an `IO String`, and IO is a *functor* so we can use `fmap` or `<$>`.
Therefore we can rewrite our main to look like this. **NOTE:** Since this is a runnable version of the blog I'm
creating a `main2` function but you are free to change `main` if you wish or even call `main2` in `main`.

```haskell
main2 :: IO ()
main2 = do
    parsedContent <- instructionParser <$> readFile "input.txt"
    let part1 = solvePart1 parsedContent
        part2 = solvePart2 parsedContent

    print part1
    print part2
```

What we now do is that `readFile "input.txt"` passes its result, that is the contents of the file to
the function on the left of `<$>` which is our `instructionParser` for us. Can you guess what the
type of `instructionParser <$> readFile "input.txt"` is?

Since `readFile "input.txt"` is of type `IO String` and passes that `String` forward to `instructionParser :: String -> [Direction]`,
that means the whole expression is of type `IO [Direction]`. And we then just pass that down to
our two solvePart functions to do their work.

::::::

:::

:::::: {.spoiler .pt2 label="Part 2"}

## Part 2

Now we want to find the position where he enters the basement (-1) for the first time.
How would you break down this given what we have already from part 1?

::: {.spoiler label="breakdown"}

- Generate a list of floors santa is on at each instruction
- Only keep a sublist up to the first basement floor
- The position would be the length of that list

:::

::: {.spoiler label="first step"}

One way to generate a list is with the `scanl` function with the type `(b -> a -> b) -> b -> [a] -> [b]`.
That can be a scary looking signature at first so let's break it down a bit.

Let's look at the two last types in between the arrows. That's `[a] -> [b]`, so we give it a list
of *a's* and we get a new list of *b's*. Simple enough. But how does it know how to turn one type to another?

First we need to give it a starting value, here noted as *b*. Since a list can have zero items the first item in
the new list is always the starting value.

Next let's take a look at the first argument that is a function of type `b -> a ->b`. This takes a
value of type `b` and another of type `a` and we are supposed to return something of type `b` which
goes into our new list. The `b` here is the same as our starting value explained in previous paragraph. The `scanl`
`a` is then each value of the list `[a]` together with the *updated* `b` value from each iteration starting with
the starting value.

But what would our function be? We would like to calculate the new floor of each iteration.

```haskell
calculateNewFloor :: Int -> Direction -> Int
calculateNewFloor currentFloor direction = currentFloor + elevationChange direction
```

Here we replace the `b` with `Int` since we want the floor numbers at each position. The `a` is replaced
with `Direction`. So we take the floor we are on and add it to the `elevationChange` of the Direction and
this either gives us an increase or decrease of floor number.

```haskell
newFloorGenerator :: [Direction] -> [Int]
newFloorGenerator = scanl calculateNewFloor 0
```

Here we put it all together and use `scanl` with `calculateNewFloor` and our starting floor of 0.

An example list generated by `scanl` given the instructions `[Up, Down, Up, Down, Down]` would be
`[0, 1, 0, 1, 0, -1]`. The first 0 is the starting value given to `scanl`.

:::

::: {.spoiler label="second step"}

Now we are only interested in only a few of the elements. We wish to take only the values as long
as they are above or equal to ground floor (0). And to do that we use the function
`takeWhile :: (a -> Bool) -> [a] -> [a]`. As you may notice this function again takes a function
as an argument. This is normal in Haskell and this is what is called a Higher Order Function, a
function that takes a function as an argument.

So what does `takeWhile` do? Notice that it takes a list of `a` and returns a list of the same `a`.
`takeWhile` keeps elements from the start of the list as long as the predicate returns True, 
and stops as soon as the predicate returns False. What do you  think `takeWhile (\a -> True) [1..5]` gives us?

```haskell
takeSubListFloor :: [Int] -> [Int]
takeSubListFloor = takeWhile (\a -> a >= 0)

takeSubListFloorTacit :: [Int] -> [Int]
takeSubListFloorTacit = takeWhile (>=0)
```

This now takes the first sub list of numbers that are 0 and above. I show two functions here
that are the same but the more we go into each problem I'll be starting to drop the longer
version and use tacit or point free style more often. It is good to start getting used to it
early on I think, especially for short functions like these.

:::

::: {.spoiler label="third step"}

Now to get the length of a list there exist such a function `length :: [a] -> Int` that takes
a list of `a` and gives us the length of that list.

```haskell
getPosition :: [Int] -> Int
getPosition = length
```

That's all there is to it. We are saying that the position is the same as the length function.

Let's now get our pieces together using function composition. Note that since `getPosition` is
actually the same as `length` we can ignore the `getPosition` function and replace it with `length`.

```haskell
combinedPart2 :: [Direction] -> Int
combinedPart2 = length . takeSubListFloor . newFloorGenerator
```

We can now call `combinedPart2` from `main` and give it our parsedContent. But we can do better.
Let's use referential transparency here and replace our function calls with their implementation.
That gives us this implementation of our part 2 solver.

```haskell
solvePart2 :: [Direction] -> Int
solvePart2 = length . takeWhile (>=0) . scanl (\b -> (+b) . elevationChange) 0
```

:::

::::::
